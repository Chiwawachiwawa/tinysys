# tinysys

# General flow

Fetch:
This unit reads an instruction at PC, decodes it and outputs it (together with its PC) to instruction output FIFO (IFIFO). If it's an interrupt or some other special instruction (for instance I$ flush) then it is handled entirely within the fetch unit. This unit is also responsible for inserting pre/post interrupt code from an internal ROM at interrupt or exception time. If a branch instruction is encountered, fetch unit will drop into an idle state and wait for the execute unit to resolve the target branch address.

The execute unit will fetch an instruction from the FIFO if available, read register values, execute (ALU/BLU/CSR/SYS) and decide on new branch target if there's a branch involved. On a branch, decision the fetch unit is notified so it can resume instruction fetches.

# Addendum: APU

TBD

# Instruction encoding space

|inst[6:5] | 000    | 001      | 010      | 011      | 100    | 101      | 110             | 111(> 32b)| inst[6:5]|
|----------|--------|----------|----------|----------|--------|----------|-----------------|-----------|----------|
|00        | LOAD   | LOAD-FP  | custom-0 | MISC-MEM | OP-IMM | AUIPC    | OP-IMM-32       | 48b       |          |
|01        | STORE  | STORE-FP | custom-1 | AMO      | OP     | LUI      | OP-32           | 64b       |          |
|10        | MADD   | MSUB     | NMSUB    | NMADD    | OP-FP  | reserved | custom-2/rv128  | 48b       |          |
|11        | BRANCH | JALR     | reserved | JAL      | SYSTEM | reserved | custom-3/rv128  | â‰¥ 80      |          |

TBD: encode custom instructions into custom-0 space (i.e. 7'b??_010_11 for a total of 4 new core instructions)

# GPU

GPU rasterization worker units:

- Input assembler:
	Listens to a command queue (setup/kick commands)
		Setup index buffer address+count
		Setup vertex buffer address (no count, max 65536)
		Kick draw
	Primitive indices are 16 bits each + one 16 bit attribute
		This makes 3x16 + 16 bits i.e. 8 bytes total per primitive
		Allows for a single 16 bytes burst to read 2 primitives
		Means indices have to be aligned to a multiple of 6 (padded if needed)
	Reads vertices cached by index
		When fetching vertices, pull from local cache if they've already been read
		(Might insert vertex program here to modify vertices, will let CPU do it for now)
	Generates edge equations for each primitive assembled
		Writes to primitive processor

- Primitive processor:
	Reads edge equations from the FIFO
	(Might add gradient generation for attribute interpolation here)
	Decides which macro tiles the primitive crosses
	Writes into coarse raster queues in round-robin order
		There are 8 coarse rasterizers shared across 300 or 1200 tiles depending on video mode

- Coarse rasterizers:
	Has a 1024 deep queue
	A coarse tile is a work unit of 16x16 pixels regardless of video mode
	Writes into fine raster unit queues in round-robin order
		There are 2 fine raster units per coarse rasterizer

- Fine raster unit:
	Has a 1024 deep queue
	A fine tile is a work unit of 4x4 pixels
	Picks up all fine tiles generated by its coarse raster unit
	Generates final triangle output into tile cache, notifies combiner
	(Might add depth test before writes here)

- Output combiner:
	Decodes fine raster tile into correct representation using video mode information (i.e. Resolve() )
	Final output goes onto the GPU write page
