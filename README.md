# tinysys

# General flow

Fetch unit reads an instruction at PC, decodes it and outputs it (together with its PC) to instruction output FIFO (IFIFO).

The execute unit will fetch an instruction from the FIFO if available, read register values, execute (ALU/BLU/CSR/SYS) and decide on new branch target if there's a branch involved.

Fetch handles instruction fence internally without passing it to the execute unit.

If there is a fence, branch, mret or wfi, it's handled before an interrupt request.

If there is a pending interrupt and the current instruction is a branch, first the fetch unit stalls until branch target is known, then deviates to ISR routine, then on MRET resumes from the branch target. This way even the branch-to-self instructions can be interrupted with a timer interrupt, for instance.

# Addendum: Rasterization extension

**redge rs1, offset(rs2)**

Generates equations for edges of a triangle at base address rs2 plus optional offset, and writes it to address contained in register rs1

The input data contains 16 bit signed integer screen positions, stored in three successive uint32_t, plus an extra unit32_t.
This layout ensures cache alignment (16 bytes), and the base address has to be naturally aligned to this 16 byte size as well.

**rmask rd, offset(rs1)**

Generates a 32 bit mask for a 16 by 2 pixel, 8 bit raster surface. The instruction can't complete in one clock during DISPATCH, so it will have to use a FIFO to queue up the work, no which we can wait with the rwait instruction.

Source register contains base address of the primitive to rasterize, with an optional integer start offset.

The data at the base address is the edge equation coefficients previously generated by the redge function. Like with redge, rmask has to work with cache aligned addresses as well.

**rwait**

Waits for the raster mask generation FIFO to become empty. To be used for cases where we wish all work to complete before we pass it to the GPU for a coherent/complete view.

Ideally, redge would pull one line into cache, work on all primitives in the cache, and output will go to some memory area accessible by the GPU.

The GPU will then pick the data in cache line sized bursts (128bit) and generate work for the rasterizer unit.

The rasterizer unit will in turn output 16 pixel's worth of work which also aligns to cache size.

# Instruction encoding space

|inst[6:5] | 000    | 001      | 010      | 011      | 100    | 101      | 110             | 111(> 32b)| inst[6:5]|
|----------|--------|----------|----------|----------|--------|----------|-----------------|-----------|----------|
|00        | LOAD   | LOAD-FP  | custom-0 | MISC-MEM | OP-IMM | AUIPC    | OP-IMM-32       | 48b       |          |
|01        | STORE  | STORE-FP | custom-1 | AMO      | OP     | LUI      | OP-32           | 64b       |          |
|10        | MADD   | MSUB     | NMSUB    | NMADD    | OP-FP  | reserved | custom-2/rv128  | 48b       |          |
|11        | BRANCH | JALR     | reserved | JAL      | SYSTEM | reserved | custom-3/rv128  | â‰¥ 80      |          |

The custom instructions have been encoded into the custom-0 space and have the following bit patterns:

**redge:** 7'b0001011

**rmask:** 7'b0101011

**rwait:** 7'b1001011