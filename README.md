# tinysys

# General flow

Fetch:
This unit reads an instruction at PC, decodes it and outputs it (together with its PC) to instruction output FIFO (IFIFO). If it's an interrupt or some other special instruction (for instance I$ flush) then it is handled entirely within the fetch unit. This unit is also responsible for inserting pre/post interrupt code from an internal ROM at interrupt or exception time. If a branch instruction is encountered, fetch unit will drop into an idle state and wait for the execute unit to resolve the target branch address.

The execute unit will fetch an instruction from the FIFO if available, read register values, execute (ALU/BLU/CSR/SYS) and decide on new branch target if there's a branch involved. On a branch, decision the fetch unit is notified so it can resume instruction fetches.

# Addendum: APU

TBD

# Addendum: GPU

TBD

# Addendum: CPU side rasterization instructions

Tinysys extends the RISC-V instruction set with some helpers to aid in rasterization. The following lists details the new instructions and their usage.

**redge rs1, offset(rs2)**

Generates equations for edges of a triangle at base address rs2 plus optional offset, and writes it to address contained in register rs1

The input data contains 16 bit signed integer screen positions, stored in three successive uint32_t, plus an extra unit32_t.
This layout ensures cache alignment (16 bytes), and the base address has to be naturally aligned to this 16 byte size as well.

**rmask rd, offset(rs1)**

Generates a 32 bit mask for a 16 by 2 pixel, 8 bit raster surface. The instruction can't complete in one clock during DISPATCH, so it will have to use a FIFO to queue up the work, no which we can wait with the rwait instruction.

Source register contains base address of the primitive to rasterize, with an optional integer start offset.

The data at the base address is the edge equation coefficients previously generated by the redge function. Like with redge, rmask has to work with cache aligned addresses as well.

**rwait**

Waits for the raster mask generation FIFO to become empty. To be used for cases where we wish all work to complete before we pass it to the GPU for a coherent/complete view.

Ideally, redge would pull one line into cache, work on all primitives in the cache, and output will go to some memory area accessible by the GPU.

The GPU will then pick the data in cache line sized bursts (128bit) and generate work for the rasterizer unit.

The rasterizer unit will in turn output 16 pixel's worth of work which also aligns to cache size.

# Instruction encoding space

|inst[6:5] | 000    | 001      | 010      | 011      | 100    | 101      | 110             | 111(> 32b)| inst[6:5]|
|----------|--------|----------|----------|----------|--------|----------|-----------------|-----------|----------|
|00        | LOAD   | LOAD-FP  | custom-0 | MISC-MEM | OP-IMM | AUIPC    | OP-IMM-32       | 48b       |          |
|01        | STORE  | STORE-FP | custom-1 | AMO      | OP     | LUI      | OP-32           | 64b       |          |
|10        | MADD   | MSUB     | NMSUB    | NMADD    | OP-FP  | reserved | custom-2/rv128  | 48b       |          |
|11        | BRANCH | JALR     | reserved | JAL      | SYSTEM | reserved | custom-3/rv128  | â‰¥ 80      |          |

The custom instructions have been encoded into the custom-0 space and have the following bit patterns:

**redge:** 7'b0001011

**rmask:** 7'b0101011

**rwait:** 7'b1001011