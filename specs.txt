CPU:
32 bit CPU running at 166.6MHz, approximately 5 clocks per instruction
Based on RISC-V architecture
Implements the rv32imc_zicsr_zifencei feature set (32bit base instruction set, intereger div/mul, 4096 control/status registers, I$/D$ fence and flush instructions, software/hardware/timer interrupts, compressed instructions)
32Kbytes instruction cache
32Kbytes data cache
64Kbytes of ROM for the OS
No branch prediction
No memory management unit (i.e. no virtual memory)

Memory:
256MBytes of DDR3 SDRAM
Cached access from CPU and direct access from other devices on the bus, in 128bit bursts

Devices:
Memory mapped access to the following devices:
- Single color triangle rasterizer
- 16bit stereo audio output (44/22/11KHz selectable)
- OPL2 device (clone of YM3812, mono output, mixed together with 16bit stereo audio)
- A polygon rasterizer implemented in hardware
- Device temperature monitor, accessible from user software
- DMA (currently handles 16-byte aligned block transfers within the 256Mbyte SDRAM region only)
- DVI signal over HDMI port (640x480 or 320x240 modes with 8bpp indexed or 16bpp truecolor for a total of 4 modes)
- SDCard slot
- USB-C port for serial connection to a host PC / power
- USB-A port for peripheral connectivity
- One soft-reset button (generates an OS interrupt, functionality can be changed if needed)
- SRAM slot for a 512K statick ram (not populated or wired yet, didn't have much use initially)
- 4 user / debug LEDs (currently used by OS for status indication, user software can also access these)

Unused:
- Space for a 512K (16bit per clock) SRAM chip, currently not implemented in hardware
- Space for a single flat speaker, not attached on current board (using headphone output instead)

OS:
Custom OS in ROM with preemptive multitasking, copied to RAM at boot
Can instead chain to user binary from SDCard (will lose ALL OS features, direct to metal access, highest performance)
Can load / stop / debug user binaries in ELF format
Runs ELF files generated by riscv gcc directly (riscv64-unknown-elf-gcc with 32 bit output)
Implements memory allocation (s_brk) and file IO syscalls
Handles serial I/O via MAX3420E (main debug interface)
Handles host features via MAX3421E (keyboard/mouse/joystick)
Implements a simple CLI that can execute basic maintenance tasks / load ELF files from storage
Implements a simle GDB stub for debugging
Implements USB host device drivers (keyboard/mouse/joystick for now, can be expanded if needed at cost of ROM space)
Handles all task switching (currently 2 OS threads + 1 ELF can run simultaneously)

NOTES:
The custom board that houses this system contains two USB control chips, one audio DAC and the SDCard reader, one soft-reset button, as well as connectors for peripherals and power. There is also a 5v to 3v3 conversion circuit so that the power can be drawn from the USB-C port.
The board is designed to carry a QMTECH A7-200T FPGA core board (i.e. it has nothing more than a blank FPGA, one DDR3 SDRAM chip, and power circuitry). The entire system is implemented in SystemVerilog to run inside this chip.
Future revisions of the board will include this chip directly onboard so that'll cut the requirement for an daughterboard, but for this version that's one thing that limits number of devices that can be made (I currently have only two of those QMTECH core boards available)


RASTERIZER:

Input Assembler (IA): Reads triangles, rejects or generates AABB, calculates edge A/B/C at min corner and also x and y gradients, pushes work to pool of sweep rasterizers
Sweep Rasterizer (RS): Grabs work from input fifo, sweep-scans and emits a write mask + output color data + target tile address to output fifo for output merger
Output Merger (OM): Gathers sweep rasterizer outputs and combines + writes them to raster out caches (one per tile)
